<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Heat Stress Map</title>

  <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
  <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet"/>

  <style>
    html, body { margin: 0; height: 100%; background: #0f0f12; }

    #mapWrap{
      position: relative;
      height: 650px;
      width: 100%;
      border-radius: 16px;
      overflow: hidden;
      background: #0f0f12;
    }

    #map{ position: absolute; inset: 0; }

    .maplibregl-ctrl-top-left .maplibregl-ctrl { margin: 10px 0 0 10px; }
    .maplibregl-ctrl-top-right .maplibregl-ctrl { margin: 10px 10px 0 0; }
    .maplibregl-ctrl-top-right{ top: 56px; }

    .basemap-toggle{
      position: absolute;
      right: 12px;
      top: 12px;
      z-index: 95;
      display: inline-flex;
      background: rgba(255,255,255,0.98);
      border: 1px solid rgba(0,0,0,0.12);
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(0,0,0,0.18);
    }
    .bm-btn{
      border: 0;
      background: transparent;
      cursor: pointer;
      width: 96px;
      text-align: center;
      padding: 8px 0;
      font: 750 13px system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color: rgba(0,0,0,0.70);
      user-select: none;
    }
    .bm-btn.active{
      background: rgba(0,0,0,0.06);
      color: rgba(0,0,0,0.92);
    }
    .bm-divider{ width: 1px; background: rgba(0,0,0,0.10); }

    .search-ctrl{ position:absolute; left:12px; top:12px; z-index:80; }
    .search-wrap{
      width: 280px; height: 44px;
      display:flex; align-items:center;
      background: #ffffff;
      border-radius: 999px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
      border: 1px solid rgba(0,0,0,0.10);
      overflow:hidden;
    }
    .search-input{
      flex:1; height: 44px;
      padding: 0 14px 0 16px;
      border: 0; outline: none;
      background: transparent;
      color: #111;
      font: 600 14px system-ui, -apple-system, Segoe UI, Roboto, Arial;
    }
    .search-input::placeholder{ color: rgba(0,0,0,0.55); font-weight: 600; }
    .search-icon-btn{
      width: 44px; height: 44px;
      border: 0; background: transparent;
      cursor: pointer;
      display:flex; align-items:center; justify-content:center;
    }
    .search-icon-btn svg{ width: 20px; height: 20px; fill: rgba(0,0,0,0.75); }

    .suggest-box{
      position: absolute; left: 0; top: 52px;
      width: 280px;
      background: rgba(255,255,255,0.98);
      border: 1px solid rgba(0,0,0,0.12);
      border-radius: 14px;
      box-shadow: 0 18px 50px rgba(0,0,0,0.22);
      overflow: hidden;
      z-index: 9999;
    }
    .suggest-item{
      padding: 10px 14px;
      cursor: pointer;
      font: 650 13px system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color: rgba(0,0,0,0.88);
      border-bottom: 1px solid rgba(0,0,0,0.06);
      user-select: none;
    }
    .suggest-item:last-child{ border-bottom: 0; }
    .suggest-item:hover, .suggest-item.active{ background: rgba(0,0,0,0.06); }
    .hidden{ display:none; }
  </style>
</head>

<body>
  <div id="mapWrap">
    <div id="map"></div>

    <div class="basemap-toggle" role="tablist" aria-label="Basemap">
      <button id="bmMap" class="bm-btn" type="button" role="tab" aria-selected="false">Map</button>
      <div class="bm-divider"></div>
      <button id="bmSat" class="bm-btn" type="button" role="tab" aria-selected="false">Satellite</button>
    </div>

    <div class="search-ctrl">
      <div class="search-wrap">
        <input id="searchBox" class="search-input" type="text" placeholder="Search" autocomplete="off" />
        <button id="searchBtn" class="search-icon-btn" type="button" aria-label="Search">
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <path d="M10 2a8 8 0 105.293 14.293l4.707 4.707 1.414-1.414-4.707-4.707A8 8 0 0010 2zm0 2a6 6 0 110 12 6 6 0 010-12z"/>
          </svg>
        </button>
      </div>
      <div id="suggestBox" class="suggest-box hidden" role="listbox" aria-label="Search suggestions"></div>
    </div>
  </div>

  <script>
    // =====================================================
    // Basemaps (with a GUARANTEED fallback for Map)
    // =====================================================

    // Preferred Map basemap (vector)
    const OFM_LIBERTY = "https://tiles.openfreemap.org/styles/liberty";

    // Fallback Map basemap (raster) => never depends on remote style JSON
    const OSM_RASTER_FALLBACK = {
      version: 8,
      sources: {
        osm: {
          type: "raster",
          tiles: ["https://tile.openstreetmap.org/{z}/{x}/{y}.png"],
          tileSize: 256,
          attribution: "© OpenStreetMap contributors"
        }
      },
      layers: [{ id: "osm", type: "raster", source: "osm" }]
    };

    // Satellite basemap (inline style object)
    const SAT_GLOBAL_PLUS_NRW = {
      version: 8,
      sources: {
        s2: {
          type: "raster",
          tiles: [
            "https://tiles.maps.eox.at/wmts/1.0.0/s2cloudless-2024_3857/default/GoogleMapsCompatible/{z}/{y}/{x}.jpg"
          ],
          tileSize: 256,
          attribution: "Sentinel-2 cloudless (EOX) / Copernicus Sentinel data"
        },
        nrw_dop: {
          type: "raster",
          tiles: [
            "https://www.wms.nrw.de/geobasis/wms_nw_dop" +
            "?SERVICE=WMS&VERSION=1.3.0&REQUEST=GetMap" +
            "&LAYERS=nw_dop_rgb&STYLES=" +
            "&FORMAT=image/png&TRANSPARENT=TRUE" +
            "&WIDTH=256&HEIGHT=256" +
            "&CRS=EPSG:3857" +
            "&BBOX={bbox-epsg-3857}"
          ],
          tileSize: 256,
          attribution: "Geobasis NRW – Digitale Orthophotos (DOP)"
        }
      },
      layers: [
        { id: "s2", type: "raster", source: "s2" },
        { id: "nrw_dop", type: "raster", source: "nrw_dop", minzoom: 10, paint: { "raster-opacity": 1 } }
      ]
    };

    const BASEMAPS = { map: OFM_LIBERTY, sat: SAT_GLOBAL_PLUS_NRW };
    const BASEMAP_STORAGE_KEY = "hs_basemap_choice_v2";

    function getSavedBasemapKey() {
      try {
        const v = localStorage.getItem(BASEMAP_STORAGE_KEY);
        return (v === "sat" || v === "map") ? v : "map";
      } catch (e) { return "map"; }
    }
    function saveBasemapKey(key) {
      try { localStorage.setItem(BASEMAP_STORAGE_KEY, key); } catch (e) {}
    }

    const CENTER = (typeof __CENTER__ !== "undefined") ? __CENTER__ : [7.0123, 51.4556];
    const ZOOM   = (typeof __ZOOM__   !== "undefined") ? __ZOOM__   : 11;
    const MAX_PITCH = 85;

    // Streamlit payload (boundaries)
    const OVERLAYS = (typeof __OVERLAYS_PAYLOAD__ !== "undefined") ? __OVERLAYS_PAYLOAD__ : null;

    let activeBasemapKey = getSavedBasemapKey();
    let pendingCamera = null;

    const map = new maplibregl.Map({
      container: "map",
      style: BASEMAPS[activeBasemapKey],
      center: CENTER,
      zoom: ZOOM,
      pitch: 0,
      bearing: 0,
      antialias: true,
      maxPitch: MAX_PITCH,
      pitchWithRotate: true
    });

    map.addControl(new maplibregl.NavigationControl({ showZoom: true, showCompass: true }), "top-right");
    map.addControl(new maplibregl.FullscreenControl({ container: document.getElementById("mapWrap") }), "top-right");
    map.addControl(new maplibregl.ScaleControl({ maxWidth: 120, unit: "metric" }), "bottom-left");

    document.addEventListener("fullscreenchange", () => { try { map.resize(); } catch(e) {} });

    // =====================================================
    // TERRAIN + HILLSHADE (safe)
    // =====================================================
    function applyTerrainSafe() {
      try {
        if (!map.getSource("dem")) {
          map.addSource("dem", {
            type: "raster-dem",
            tiles: ["https://s3.amazonaws.com/elevation-tiles-prod/terrarium/{z}/{x}/{y}.png"],
            tileSize: 256,
            encoding: "terrarium"
          });
        }

        map.setTerrain({ source: "dem", exaggeration: 1.2 });

        if (!map.getLayer("hillshade")) {
          const layers = (map.getStyle() && map.getStyle().layers) ? map.getStyle().layers : [];
          const firstSymbol = layers.find(l => l.type === "symbol");
          const beforeId = firstSymbol ? firstSymbol.id : undefined;

          map.addLayer({ id: "hillshade", type: "hillshade", source: "dem" }, beforeId);
        }
      } catch (e) {
        // never block boundaries
      }
    }

    // =====================================================
    // CITY BOUNDARIES (cached)
    // =====================================================
    const BND_SRC  = "city-boundaries";
    const BND_LINE = "city-boundaries-line";

    function boundaryLineColor() {
      return (activeBasemapKey === "sat")
        ? "rgba(255,255,255,0.92)"
        : "rgba(0,0,0,0.92)";
    }

    let boundaryPromise = null;

    function getBoundaryFC() {
      if (boundaryPromise) return boundaryPromise;

      boundaryPromise = (async () => {
        if (!OVERLAYS) return null;

        if (OVERLAYS.boundary_geojson && OVERLAYS.boundary_geojson.type === "FeatureCollection") {
          return OVERLAYS.boundary_geojson;
        }

        if (Array.isArray(OVERLAYS.boundary_layers) && OVERLAYS.boundary_layers.length) {
          const feats = [];
          for (const L of OVERLAYS.boundary_layers) {
            try {
              const r = await fetch(L.url, { headers: { "Accept": "application/json" } });
              if (!r.ok) continue;
              const gj = await r.json();
              const fs = Array.isArray(gj.features) ? gj.features : [];
              for (const f of fs) feats.push(f);
            } catch (e) {}
          }
          return feats.length ? { type: "FeatureCollection", features: feats } : null;
        }

        return null;
      })();

      return boundaryPromise;
    }

    async function ensureCityBoundaries() {
      const fc = await getBoundaryFC();
      if (!fc) return;

      if (!map.getSource(BND_SRC)) {
        map.addSource(BND_SRC, { type: "geojson", data: fc });
      } else {
        map.getSource(BND_SRC).setData(fc);
      }

      const layers = (map.getStyle() && map.getStyle().layers) ? map.getStyle().layers : [];
      const firstSymbol = layers.find(l => l.type === "symbol");
      const beforeId = firstSymbol ? firstSymbol.id : undefined;

      if (!map.getLayer(BND_LINE)) {
        map.addLayer({
          id: BND_LINE,
          type: "line",
          source: BND_SRC,
          layout: { "line-join": "round", "line-cap": "round" },
          paint: { "line-color": boundaryLineColor(), "line-width": 2.6 }
        }, beforeId);
      } else {
        map.setPaintProperty(BND_LINE, "line-color", boundaryLineColor());
      }
    }

    // =====================================================
    // ✅ Rehydrate on every style.load (DO NOT wait for isStyleLoaded)
    // =====================================================
    let rehydrateToken = 0;

    function requestRehydrate(reason) {
      const token = ++rehydrateToken;
      setTimeout(async () => {
        if (token !== rehydrateToken) return;

        if (pendingCamera) {
          try { map.jumpTo(pendingCamera); } catch(e) {}
          pendingCamera = null;
        }

        try { map.setMaxPitch(MAX_PITCH); } catch(e) {}
        applyTerrainSafe();
        try { await ensureCityBoundaries(); } catch(e) {}

        // Streamlit/iframe safety
        try { map.resize(); } catch(e) {}
      }, 0);
    }

    map.once("load", () => {
      map.easeTo({ pitch: 0, bearing: 0, duration: 0 });
      requestRehydrate("initial-load");
      setTimeout(() => { try { map.resize(); } catch(e) {} }, 100);
    });

    map.on("style.load", () => {
      requestRehydrate("style.load");
      setTimeout(() => { try { map.resize(); } catch(e) {} }, 100);
    });

    // =====================================================
    // ✅ GUARANTEED MAP LOAD: if OpenFreeMap fails, switch to OSM raster
    // =====================================================
    let mapFallbackUsed = false;
    let watchdogToken = 0;

    function startMapStyleWatchdog() {
      const t = ++watchdogToken;
      setTimeout(() => {
        if (t !== watchdogToken) return;
        if (activeBasemapKey !== "map") return;

        // If style is still not loaded after 6s, force fallback.
        if (!map.isStyleLoaded() && !mapFallbackUsed) {
          mapFallbackUsed = true;
          map.setStyle(OSM_RASTER_FALLBACK);
        }
      }, 6000);
    }

    map.on("error", (e) => {
      const msg = (e && e.error && e.error.message) ? e.error.message : "";
      if (activeBasemapKey === "map" && !mapFallbackUsed) {
        // If OpenFreeMap style fails to fetch, fallback immediately.
        if (msg.includes("openfreemap") || msg.includes("Failed to load") || msg.includes("NetworkError")) {
          mapFallbackUsed = true;
          map.setStyle(OSM_RASTER_FALLBACK);
        }
      }
    });

    // =====================================================
    // Basemap toggle UI
    // =====================================================
    const bmMapBtn = document.getElementById("bmMap");
    const bmSatBtn = document.getElementById("bmSat");

    function syncToggleUI() {
      const isMap = activeBasemapKey === "map";
      bmMapBtn.classList.toggle("active", isMap);
      bmSatBtn.classList.toggle("active", !isMap);
      bmMapBtn.setAttribute("aria-selected", String(isMap));
      bmSatBtn.setAttribute("aria-selected", String(!isMap));
    }

    function setBasemap(key) {
      if (key !== "map" && key !== "sat") return;
      if (key === activeBasemapKey) return;

      pendingCamera = {
        center: map.getCenter(),
        zoom: map.getZoom(),
        pitch: map.getPitch(),
        bearing: map.getBearing()
      };

      activeBasemapKey = key;
      saveBasemapKey(key);
      syncToggleUI();

      map.setStyle(BASEMAPS[key]);

      // If switching to Map, start watchdog so it never stays blank.
      if (key === "map") startMapStyleWatchdog();
    }

    bmMapBtn.addEventListener("click", () => setBasemap("map"));
    bmSatBtn.addEventListener("click", () => setBasemap("sat"));
    syncToggleUI();

    // If we start on map, watchdog too
    if (activeBasemapKey === "map") startMapStyleWatchdog();

    // =====================================================
    // Search (Photon autosuggest + search)
    // =====================================================
    const inputEl = document.getElementById("searchBox");
    const btnEl = document.getElementById("searchBtn");
    const suggestBox = document.getElementById("suggestBox");

    let suggestTimer = null;
    let lastItems = [];
    let activeIdx = -1;

    function hideSuggest() {
      suggestBox.classList.add("hidden");
      suggestBox.innerHTML = "";
      lastItems = [];
      activeIdx = -1;
    }

    function setActive(idx) {
      const children = Array.from(suggestBox.children);
      children.forEach((c, i) => c.classList.toggle("active", i === idx));
      activeIdx = idx;
    }

    function chooseSuggestion(idx) {
      const it = lastItems[idx];
      if (!it) return;

      inputEl.value = it.label;
      hideSuggest();

      map.flyTo({
        center: [it.lon, it.lat],
        zoom: Math.max(map.getZoom(), 12),
        duration: 900
      });
    }

    function renderSuggest(items) {
      lastItems = items;
      activeIdx = -1;

      if (!items || !items.length) {
        hideSuggest();
        return;
      }

      suggestBox.innerHTML = "";
      items.forEach((it, i) => {
        const div = document.createElement("div");
        div.className = "suggest-item";
        div.setAttribute("role", "option");
        div.textContent = it.label;

        div.addEventListener("mousedown", (e) => {
          e.preventDefault();
          chooseSuggestion(i);
        });

        suggestBox.appendChild(div);
      });

      suggestBox.classList.remove("hidden");
    }

    function buildLabel(p) {
      const parts = [
        p.name,
        p.housenumber && p.street ? `${p.housenumber} ${p.street}` : (p.street || null),
        p.city,
        p.state,
        p.country
      ].filter(Boolean);
      return parts.join(", ") || p.label || "Unknown place";
    }

    async function photonSuggest(q, limit = 6) {
      const url = "https://photon.komoot.io/api/?q=" + encodeURIComponent(q) + "&limit=" + limit;
      const r = await fetch(url, { headers: { "Accept": "application/json" } });
      const data = await r.json();
      const feats = (data && Array.isArray(data.features)) ? data.features : [];

      return feats.map(f => {
        const coords = f?.geometry?.coordinates;
        const p = f?.properties || {};
        return {
          label: buildLabel(p),
          lon: Array.isArray(coords) ? Number(coords[0]) : NaN,
          lat: Array.isArray(coords) ? Number(coords[1]) : NaN
        };
      }).filter(x => Number.isFinite(x.lon) && Number.isFinite(x.lat));
    }

    async function doSearch() {
      const q = (inputEl.value || "").trim();
      if (!q) return;

      btnEl.disabled = true;
      try {
        if (activeIdx >= 0 && activeIdx < lastItems.length) {
          chooseSuggestion(activeIdx);
          return;
        }

        const items = await photonSuggest(q, 1);
        if (!items.length) return;

        map.flyTo({
          center: [items[0].lon, items[0].lat],
          zoom: Math.max(map.getZoom(), 12),
          duration: 900
        });

        hideSuggest();
      } finally {
        btnEl.disabled = false;
      }
    }

    inputEl.addEventListener("input", () => {
      const q = (inputEl.value || "").trim();
      clearTimeout(suggestTimer);

      if (q.length < 3) {
        hideSuggest();
        return;
      }

      suggestTimer = setTimeout(async () => {
        try {
          const items = await photonSuggest(q, 6);
          renderSuggest(items);
        } catch (e) {
          hideSuggest();
        }
      }, 250);
    });

    inputEl.addEventListener("keydown", (e) => {
      const open = !suggestBox.classList.contains("hidden");
      const n = lastItems.length;

      if (e.key === "Enter") {
        e.preventDefault();
        doSearch();
        return;
      }

      if (!open || !n) return;

      if (e.key === "ArrowDown") {
        e.preventDefault();
        setActive((activeIdx + 1) % n);
      } else if (e.key === "ArrowUp") {
        e.preventDefault();
        setActive((activeIdx - 1 + n) % n);
      } else if (e.key === "Escape") {
        e.preventDefault();
        hideSuggest();
      }
    });

    btnEl.addEventListener("click", doSearch);

    document.addEventListener("click", (e) => {
      const wrapper = document.querySelector(".search-ctrl");
      if (wrapper && !wrapper.contains(e.target)) hideSuggest();
    }, { passive: true });
  </script>
</body>
</html>
